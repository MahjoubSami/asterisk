diff --git a/main/Makefile b/main/Makefile
index 70b2a39..860dae4 100644
--- a/main/Makefile
+++ b/main/Makefile
@@ -44,6 +44,7 @@ AST_LIBS+=$(URIPARSER_LIB)
 AST_LIBS+=$(UUID_LIB)
 AST_LIBS+=$(CRYPT_LIB)
 AST_LIBS+=$(AST_CLANG_BLOCKS_LIBS)
+AST_LIBS+=$(OPUS_LIB)
 
 ifneq ($(findstring $(OSARCH), linux-gnu uclinux linux-uclibc kfreebsd-gnu),)
   ifneq ($(findstring LOADABLE_MODULES,$(MENUSELECT_CFLAGS)),)
@@ -163,6 +164,7 @@ json.o: _ASTCFLAGS+=$(JANSSON_INCLUDE)
 bucket.o: _ASTCFLAGS+=$(URIPARSER_INCLUDE)
 crypt.o: _ASTCFLAGS+=$(CRYPT_INCLUDE)
 uuid.o: _ASTCFLAGS+=$(UUID_INCLUDE)
+codec_builtin.o: _ASTCFLAGS+=$(OPUS_INCLUDE)
 
 ifneq ($(findstring ENABLE_UPLOADS,$(MENUSELECT_CFLAGS)),)
 http.o: _ASTCFLAGS+=$(GMIME_INCLUDE)
diff --git a/main/codec_builtin.c b/main/codec_builtin.c
index 346b47b..4e7fd56 100644
--- a/main/codec_builtin.c
+++ b/main/codec_builtin.c
@@ -38,6 +38,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 #include "asterisk/format_cache.h"
 #include "asterisk/frame.h"
 
+#include <opus/opus.h>
+
 enum frame_type {
 	TYPE_HIGH,     /* 0x0 */
 	TYPE_LOW,      /* 0x1 */
@@ -698,6 +700,11 @@ static struct ast_codec g719 = {
 	.get_length = g719_length,
 };
 
+static int opus_samples(struct ast_frame *frame)
+{
+	return opus_packet_get_nb_samples(frame->data.ptr, frame->datalen, 48000);
+}
+
 static struct ast_codec opus = {
 	.name = "opus",
 	.description = "Opus Codec",
@@ -707,6 +714,7 @@ static struct ast_codec opus = {
 	.maximum_ms = 60,
 	.default_ms = 20,
 	.minimum_bytes = 10,
+	.samples_count = opus_samples,
 };
 
 static struct ast_codec jpeg = {
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -0,0 +1,248 @@
+# generated automatically by aclocal 1.14.1 -*- Autoconf -*-
+
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])
+# pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
+# serial 1 (pkg-config-0.24)
+# 
+# Copyright Â© 2004 Scott James Remnant <scott@netsplit.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# PKG_PROG_PKG_CONFIG([MIN-VERSION])
+# ----------------------------------
+AC_DEFUN([PKG_PROG_PKG_CONFIG],
+[m4_pattern_forbid([^_?PKG_[A-Z_]+$])
+m4_pattern_allow([^PKG_CONFIG(_(PATH|LIBDIR|SYSROOT_DIR|ALLOW_SYSTEM_(CFLAGS|LIBS)))?$])
+m4_pattern_allow([^PKG_CONFIG_(DISABLE_UNINSTALLED|TOP_BUILD_DIR|DEBUG_SPEW)$])
+AC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])
+AC_ARG_VAR([PKG_CONFIG_PATH], [directories to add to pkg-config's search path])
+AC_ARG_VAR([PKG_CONFIG_LIBDIR], [path overriding pkg-config's built-in search path])
+
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	AC_PATH_TOOL([PKG_CONFIG], [pkg-config])
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=m4_default([$1], [0.9.0])
+	AC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		AC_MSG_RESULT([yes])
+	else
+		AC_MSG_RESULT([no])
+		PKG_CONFIG=""
+	fi
+fi[]dnl
+])# PKG_PROG_PKG_CONFIG
+
+# PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+#
+# Check to see whether a particular set of modules exists.  Similar
+# to PKG_CHECK_MODULES(), but does not set variables or print errors.
+#
+# Please remember that m4 expands AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+# only at the first occurence in configure.ac, so if the first place
+# it's called might be skipped (such as if it is within an "if", you
+# have to call PKG_CHECK_EXISTS manually
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_EXISTS],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+if test -n "$PKG_CONFIG" && \
+    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$1"]); then
+  m4_default([$2], [:])
+m4_ifvaln([$3], [else
+  $3])dnl
+fi])
+
+# _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
+# ---------------------------------------------
+m4_define([_PKG_CONFIG],
+[if test -n "$$1"; then
+    pkg_cv_[]$1="$$1"
+ elif test -n "$PKG_CONFIG"; then
+    PKG_CHECK_EXISTS([$3],
+                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes ],
+		     [pkg_failed=yes])
+ else
+    pkg_failed=untried
+fi[]dnl
+])# _PKG_CONFIG
+
+# _PKG_SHORT_ERRORS_SUPPORTED
+# -----------------------------
+AC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi[]dnl
+])# _PKG_SHORT_ERRORS_SUPPORTED
+
+
+# PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+# [ACTION-IF-NOT-FOUND])
+#
+#
+# Note that if there is a possibility the first call to
+# PKG_CHECK_MODULES might not happen, you should be sure to include an
+# explicit call to PKG_PROG_PKG_CONFIG in your configure.ac
+#
+#
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_MODULES],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl
+AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
+
+pkg_failed=no
+AC_MSG_CHECKING([for $1])
+
+_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
+_PKG_CONFIG([$1][_LIBS], [libs], [$2])
+
+m4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS
+and $1[]_LIBS to avoid the need to call pkg-config.
+See the pkg-config man page for more details.])
+
+if test $pkg_failed = yes; then
+   	AC_MSG_RESULT([no])
+        _PKG_SHORT_ERRORS_SUPPORTED
+        if test $_pkg_short_errors_supported = yes; then
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "$2" 2>&1`
+        else 
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "$2" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
+
+	m4_default([$4], [AC_MSG_ERROR(
+[Package requirements ($2) were not met:
+
+$$1_PKG_ERRORS
+
+Consider adjusting the PKG_CONFIG_PATH environment variable if you
+installed software in a non-standard prefix.
+
+_PKG_TEXT])[]dnl
+        ])
+elif test $pkg_failed = untried; then
+     	AC_MSG_RESULT([no])
+	m4_default([$4], [AC_MSG_FAILURE(
+[The pkg-config script could not be found or is too old.  Make sure it
+is in your PATH or set the PKG_CONFIG environment variable to the full
+path to pkg-config.
+
+_PKG_TEXT
+
+To get pkg-config, see <http://pkg-config.freedesktop.org/>.])[]dnl
+        ])
+else
+	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
+	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
+        AC_MSG_RESULT([yes])
+	$3
+fi[]dnl
+])# PKG_CHECK_MODULES
+
+
+# PKG_INSTALLDIR(DIRECTORY)
+# -------------------------
+# Substitutes the variable pkgconfigdir as the location where a module
+# should install pkg-config .pc files. By default the directory is
+# $libdir/pkgconfig, but the default can be changed by passing
+# DIRECTORY. The user can override through the --with-pkgconfigdir
+# parameter.
+AC_DEFUN([PKG_INSTALLDIR],
+[m4_pushdef([pkg_default], [m4_default([$1], ['${libdir}/pkgconfig'])])
+m4_pushdef([pkg_description],
+    [pkg-config installation directory @<:@]pkg_default[@:>@])
+AC_ARG_WITH([pkgconfigdir],
+    [AS_HELP_STRING([--with-pkgconfigdir], pkg_description)],,
+    [with_pkgconfigdir=]pkg_default)
+AC_SUBST([pkgconfigdir], [$with_pkgconfigdir])
+m4_popdef([pkg_default])
+m4_popdef([pkg_description])
+]) dnl PKG_INSTALLDIR
+
+
+# PKG_NOARCH_INSTALLDIR(DIRECTORY)
+# -------------------------
+# Substitutes the variable noarch_pkgconfigdir as the location where a
+# module should install arch-independent pkg-config .pc files. By
+# default the directory is $datadir/pkgconfig, but the default can be
+# changed by passing DIRECTORY. The user can override through the
+# --with-noarch-pkgconfigdir parameter.
+AC_DEFUN([PKG_NOARCH_INSTALLDIR],
+[m4_pushdef([pkg_default], [m4_default([$1], ['${datadir}/pkgconfig'])])
+m4_pushdef([pkg_description],
+    [pkg-config arch-independent installation directory @<:@]pkg_default[@:>@])
+AC_ARG_WITH([noarch-pkgconfigdir],
+    [AS_HELP_STRING([--with-noarch-pkgconfigdir], pkg_description)],,
+    [with_noarch_pkgconfigdir=]pkg_default)
+AC_SUBST([noarch_pkgconfigdir], [$with_noarch_pkgconfigdir])
+m4_popdef([pkg_default])
+m4_popdef([pkg_description])
+]) dnl PKG_NOARCH_INSTALLDIR
+
+
+# PKG_CHECK_VAR(VARIABLE, MODULE, CONFIG-VARIABLE,
+# [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+# -------------------------------------------
+# Retrieves the value of the pkg-config variable for the given module.
+AC_DEFUN([PKG_CHECK_VAR],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1], [value of $3 for $2, overriding pkg-config])dnl
+
+_PKG_CONFIG([$1], [variable="][$3]["], [$2])
+AS_VAR_COPY([$1], [pkg_cv_][$1])
+
+AS_VAR_IF([$1], [""], [$5], [$4])dnl
+])# PKG_CHECK_VAR
+
+m4_include([autoconf/acx_pthread.m4])
+m4_include([autoconf/ast_c_compile_check.m4])
+m4_include([autoconf/ast_c_declare_check.m4])
+m4_include([autoconf/ast_c_define_check.m4])
+m4_include([autoconf/ast_check_gnu_make.m4])
+m4_include([autoconf/ast_check_mandatory.m4])
+m4_include([autoconf/ast_check_openh323.m4])
+m4_include([autoconf/ast_check_osptk.m4])
+m4_include([autoconf/ast_check_pwlib.m4])
+m4_include([autoconf/ast_ext_lib.m4])
+m4_include([autoconf/ast_ext_tool_check.m4])
+m4_include([autoconf/ast_func_fork.m4])
+m4_include([autoconf/ast_gcc_attribute.m4])
+m4_include([autoconf/ast_pkgconfig.m4])
+m4_include([autoconf/ast_prog_egrep.m4])
+m4_include([autoconf/ast_prog_ld.m4])
+m4_include([autoconf/ast_prog_ld_gnu.m4])
+m4_include([autoconf/ast_prog_sed.m4])
+m4_include([autoconf/libcurl.m4])
--- a/codecs/codec_opus.c
+++ b/codecs/codec_opus.c
@@ -0,0 +1,561 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2014, Lorenzo Miniero
+ *
+ * Lorenzo Miniero <lorenzo@meetecho.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Translate between signed linear and Opus (Open Codec)
+ *
+ * \author Lorenzo Miniero <lorenzo@meetecho.com>
+ *
+ * \note This work was motivated by Mozilla
+ *
+ * \ingroup codecs
+ *
+ * \extref The Opus library - http://opus-codec.org
+ *
+ */
+
+/*** MODULEINFO
+	 <depend>opus</depend>
+	 <support_level>core</support_level>
+***/
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: $")
+
+#include <opus/opus.h>
+
+#include "asterisk/translate.h"
+#include "asterisk/module.h"
+#include "asterisk/config.h"
+#include "asterisk/utils.h"
+
+#define	BUFFER_SAMPLES	8000
+#define	OPUS_SAMPLES	160
+
+#define USE_FEC			0
+
+/* Sample frame data */
+#include "asterisk/slin.h"
+#include "ex_opus.h"
+
+/* FIXME: Test */
+#include "asterisk/file.h"
+
+static int encid;
+static int decid;
+
+/* Private structures */
+struct opus_coder_pvt {
+	void *opus;	/* May be encoder or decoder */
+	int sampling_rate;
+	int multiplier;
+	int fec;
+	int id;
+	int16_t buf[BUFFER_SAMPLES];	/* FIXME */
+	int framesize;
+};
+
+static int valid_sampling_rate(int rate)
+{
+	return rate == 8000
+		|| rate == 12000
+		|| rate == 16000
+		|| rate == 24000
+		|| rate == 48000;
+}
+
+/* Helper methods */
+static int opus_encoder_construct(struct ast_trans_pvt *pvt, int sampling_rate)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+	int error = 0;
+
+	if (!valid_sampling_rate(sampling_rate)) {
+		return -1;
+	}
+
+	opvt->sampling_rate = sampling_rate;
+	opvt->multiplier = 48000/sampling_rate;
+	opvt->fec = USE_FEC;
+
+	opvt->opus = opus_encoder_create(sampling_rate, 1, OPUS_APPLICATION_VOIP, &error);
+
+	if (error != OPUS_OK) {
+		ast_log(LOG_ERROR, "Error creating the Opus encoder: %s\n", opus_strerror(error));
+		return -1;
+	}
+
+	if (sampling_rate == 8000) {
+		opus_encoder_ctl(opvt->opus, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_NARROWBAND));
+	} else if(sampling_rate == 12000) {
+		opus_encoder_ctl(opvt->opus, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_MEDIUMBAND));
+	} else if(sampling_rate == 16000) {
+		opus_encoder_ctl(opvt->opus, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_WIDEBAND));
+	} else if(sampling_rate == 24000) {
+		opus_encoder_ctl(opvt->opus, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_SUPERWIDEBAND));
+	} else if(sampling_rate == 48000) {
+		opus_encoder_ctl(opvt->opus, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_FULLBAND));
+	}
+
+	opus_encoder_ctl(opvt->opus, OPUS_SET_INBAND_FEC(opvt->fec));
+	opvt->framesize = sampling_rate/50;
+	opvt->id = ++encid;
+
+	ast_debug(3, "Created encoder #%d (%d->opus)\n", opvt->id, sampling_rate);
+
+	return 0;
+}
+
+static int opus_decoder_construct(struct ast_trans_pvt *pvt, int sampling_rate)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+	int error = 0;
+
+	if (!valid_sampling_rate(sampling_rate)) {
+		return -1;
+	}
+
+	opvt->sampling_rate = sampling_rate;
+	opvt->multiplier = 48000/sampling_rate;
+	opvt->fec = USE_FEC;	/* FIXME: should be triggered by chan_sip */
+
+	opvt->opus = opus_decoder_create(sampling_rate, 1, &error);
+
+	if (error != OPUS_OK) {
+		ast_log(LOG_ERROR, "Error creating the Opus decoder: %s\n", opus_strerror(error));
+		return -1;
+	}
+
+	opvt->id = ++decid;
+
+	ast_debug(3, "Created decoder #%d (opus->%d)\n", opvt->id, sampling_rate);
+
+	return 0;
+}
+
+/* Translator callbacks */
+static int lintoopus_new(struct ast_trans_pvt *pvt)
+{
+	return opus_encoder_construct(pvt, pvt->t->src_codec.sample_rate);
+}
+
+static int opustolin_new(struct ast_trans_pvt *pvt)
+{
+	return opus_decoder_construct(pvt, pvt->t->dst_codec.sample_rate);
+}
+
+static int lintoopus_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+
+	/* XXX We should look at how old the rest of our stream is, and if it
+	   is too old, then we should overwrite it entirely, otherwise we can
+	   get artifacts of earlier talk that do not belong */
+	memcpy(opvt->buf + pvt->samples, f->data.ptr, f->datalen);
+	pvt->samples += f->samples;
+
+	return 0;
+}
+
+static struct ast_frame *lintoopus_frameout(struct ast_trans_pvt *pvt)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+	int datalen = 0;	/* output bytes */
+	int samples = 0;	/* output samples */
+
+	/* We can't work on anything less than a frame in size */
+	if (pvt->samples < opvt->framesize) {
+		return NULL;
+	}
+
+	/* Encode 160 samples (or more if it's not narrowband) */
+	ast_debug(3, "[Encoder #%d (%d)] %d samples, %d bytes\n",
+		opvt->id,
+		opvt->sampling_rate,
+		opvt->framesize,
+		opvt->framesize * 2);
+
+	datalen = opus_encode(opvt->opus, opvt->buf, opvt->framesize, pvt->outbuf.uc, BUFFER_SAMPLES);
+
+	if (datalen < 0) {
+		ast_log(LOG_ERROR, "Error encoding the Opus frame: %s\n", opus_strerror(datalen));
+		return NULL;
+	}
+
+	samples += opvt->framesize;
+	pvt->samples -= opvt->framesize;
+
+	/* Move the data at the end of the buffer to the front */
+	if (pvt->samples) {
+		memmove(opvt->buf, opvt->buf + samples, pvt->samples * 2);
+	}
+
+	ast_debug(3, "[Encoder #%d (%d)]   >> Got %d samples, %d bytes\n",
+		opvt->id,
+		opvt->sampling_rate,
+		opvt->multiplier * samples,
+		datalen);
+
+	return ast_trans_frameout(pvt, datalen, opvt->multiplier * samples);
+}
+
+static int opustolin_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)
+{
+	struct opus_coder_pvt *opvt = pvt->pvt;
+	int error = 0;
+
+	/* Decode */
+	ast_debug(3, "[Decoder #%d (%d)] %d samples, %d bytes\n",
+		opvt->id,
+		opvt->sampling_rate,
+		f->samples,
+		f->datalen);
+
+	error = opus_decode(opvt->opus, f->data.ptr, f->datalen, pvt->outbuf.i16, BUFFER_SAMPLES, opvt->fec);
+
+	if (error < 0) {
+		ast_log(LOG_ERROR, "Error decoding the Opus frame: %s\n", opus_strerror(error));
+		return -1;
+	}
+
+	pvt->samples += error;
+	pvt->datalen += error * 2;
+
+	ast_debug(3, "[Decoder #%d (%d)]   >> Got %d samples, %d bytes\n",
+		opvt->id,
+		opvt->sampling_rate,
+		pvt->samples,
+		pvt->datalen);
+
+	return 0;
+}
+
+static void lintoopus_destroy(struct ast_trans_pvt *arg)
+{
+	struct opus_coder_pvt *opvt = arg->pvt;
+
+	if (opvt || opvt->opus) {
+		return;
+	}
+
+	opus_encoder_destroy(opvt->opus);
+	opvt->opus = NULL;
+
+	ast_debug(3, "Destroyed encoder #%d (%d->opus)\n", opvt->id, opvt->sampling_rate);
+}
+
+static void opustolin_destroy(struct ast_trans_pvt *arg)
+{
+	struct opus_coder_pvt *opvt = arg->pvt;
+
+	if (!opvt || !opvt->opus) {
+		return;
+	}
+
+	opus_decoder_destroy(opvt->opus);
+	opvt->opus = NULL;
+
+	ast_debug(3, "Destroyed decoder #%d (opus->%d)\n", opvt->id, opvt->sampling_rate);
+}
+
+/* Translators */
+static struct ast_translator opustolin = {
+        .name = "opustolin",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 8000,
+        },
+        .format = "slin",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator lintoopus = {
+        .name = "lintoopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 8000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .sample = slin8_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator opustolin12 = {
+        .name = "opustolin12",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 12000,
+        },
+        .format = "slin12",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator lin12toopus = {
+        .name = "lin12toopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 12000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator opustolin16 = {
+        .name = "opustolin16",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 16000,
+        },
+        .format = "slin16",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator lin16toopus = {
+        .name = "lin16toopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 16000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .sample = slin16_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator opustolin24 = {
+        .name = "opustolin24",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 24000,
+        },
+        .format = "slin24",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator lin24toopus = {
+        .name = "lin24toopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 24000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator opustolin48 = {
+        .name = "opustolin48",
+        .src_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "slin48",
+        .newpvt = opustolin_new,
+        .framein = opustolin_framein,
+        .destroy = opustolin_destroy,
+        .sample = opus_sample,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+static struct ast_translator lin48toopus = {
+        .name = "lin48toopus",
+        .src_codec = {
+                .name = "slin",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .dst_codec = {
+                .name = "opus",
+                .type = AST_MEDIA_TYPE_AUDIO,
+                .sample_rate = 48000,
+        },
+        .format = "opus",
+        .newpvt = lintoopus_new,
+        .framein = lintoopus_framein,
+        .frameout = lintoopus_frameout,
+        .destroy = lintoopus_destroy,
+        .desc_size = sizeof(struct opus_coder_pvt),
+        .buffer_samples = BUFFER_SAMPLES,
+        .buf_size = BUFFER_SAMPLES * 2,
+};
+
+/* Configuration and module setup */
+static int parse_config(int reload)
+{
+	/* TODO: place stuff to negotiate/enforce here */
+	return 0;
+}
+
+static int reload(void)
+{
+	if (parse_config(1)) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	int res = 0;
+
+	res |= ast_unregister_translator(&opustolin);
+	res |= ast_unregister_translator(&lintoopus);
+	res |= ast_unregister_translator(&opustolin12);
+	res |= ast_unregister_translator(&lin12toopus);
+	res |= ast_unregister_translator(&opustolin16);
+	res |= ast_unregister_translator(&lin16toopus);
+	res |= ast_unregister_translator(&opustolin24);
+	res |= ast_unregister_translator(&lin24toopus);
+	res |= ast_unregister_translator(&opustolin48);
+	res |= ast_unregister_translator(&lin48toopus);
+
+	return res;
+}
+
+static int load_module(void)
+{
+	int res = 0;
+
+	if (parse_config(0)) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	res |= ast_register_translator(&opustolin);
+	res |= ast_register_translator(&lintoopus);
+	res |= ast_register_translator(&opustolin12);
+	res |= ast_register_translator(&lin12toopus);
+	res |= ast_register_translator(&opustolin16);
+	res |= ast_register_translator(&lin16toopus);
+	res |= ast_register_translator(&opustolin24);
+	res |= ast_register_translator(&lin24toopus);
+	res |= ast_register_translator(&opustolin48);
+	res |= ast_register_translator(&lin48toopus);
+
+	return res;
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "Opus Coder/Decoder",
+	.load = load_module,
+	.unload = unload_module,
+	.reload = reload,
+	);
--- a/codecs/ex_opus.h
+++ b/codecs/ex_opus.h
@@ -0,0 +1,35 @@
+/*! \file
+ * \brief 8-bit data
+ *
+ * Copyright (C) 2014, Lorenzo Miniero
+ *
+ * Distributed under the terms of the GNU General Public License
+ *
+ */
+
+/* Opus, a 20ms sample */
+static uint8_t ex_opus[] = {
+	0x4b, 0x41, 0x25, 0x0b, 0xe4, 0x55, 0xc6, 0x74,
+	0xda, 0xbb, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static struct ast_frame *opus_sample(void)
+{
+	static struct ast_frame f = {
+		.frametype = AST_FRAME_VOICE,
+		.datalen = sizeof(ex_opus),
+		.samples = 960,	// ARRAY_LEN(ex_opus),
+		.mallocd = 0,
+		.offset = 0,
+		.src = __PRETTY_FUNCTION__,
+		.data.ptr = ex_opus,
+	};
+
+	f.subclass.format = ast_format_opus;
+
+	return &f;
+}
--- a/formats/format_vp8.c
+++ b/formats/format_vp8.c
@@ -0,0 +1,203 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2014, Lorenzo Miniero
+ *
+ * Lorenzo Miniero <lorenzo@meetecho.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Save to raw, headerless VP8 data.
+ *
+ * \author Lorenzo Miniero <lorenzo@meetecho.com>
+ *
+ * \note Basically a "clone" of the H.264 passthrough format
+ *
+ * \arg File name extension: VP8
+ * \ingroup formats
+ * \arg See \ref AstVideo
+ */
+
+/*** MODULEINFO
+	 <support_level>core</support_level>
+***/
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: $")
+
+#include "asterisk/mod_format.h"
+#include "asterisk/module.h"
+#include "asterisk/endian.h"
+#include "asterisk/format_cache.h"
+
+/* VP8 passthrough */
+#define FRAME_ENDED	0x8000
+
+#define BUF_SIZE	4096
+struct vp8_desc {
+	unsigned int lastts;
+};
+
+static int vp8_open(struct ast_filestream *s)
+{
+	unsigned int ts;
+
+	if (fread(&ts, 1, sizeof(ts), s->f) < sizeof(ts)) {
+		ast_log(LOG_WARNING, "Empty file!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static struct ast_frame *vp8_read(struct ast_filestream *s, int *whennext)
+{
+	int res;
+	int mark = 0;
+	unsigned short len;
+	unsigned int ts;
+	struct vp8_desc *fs = (struct vp8_desc *) s->_private;
+
+	/* Send a frame from the file to the appropriate channel */
+	if ((res = fread(&len, 1, sizeof(len), s->f)) < 1) {
+		return NULL;
+	}
+
+	len = ntohs(len);
+	mark = (len & FRAME_ENDED) ? 1 : 0;
+	len &= 0x7fff;
+	if (len > BUF_SIZE) {
+		ast_log(LOG_WARNING, "Length %d is too long\n", len);
+		len = BUF_SIZE;	/* XXX truncate */
+	}
+	s->fr.mallocd = 0;
+	AST_FRAME_SET_BUFFER(&s->fr, s->buf, AST_FRIENDLY_OFFSET, len);
+	if ((res = fread(s->fr.data.ptr, 1, s->fr.datalen, s->f)) != s->fr.datalen) {
+		if (res) {
+			ast_log(LOG_WARNING, "Short read (%d of %d) (%s)!\n", res, len, strerror(errno));
+		}
+		return NULL;
+	}
+	s->fr.samples = fs->lastts;
+	s->fr.datalen = len;
+	s->fr.subclass.frame_ending = mark;
+	s->fr.delivery.tv_sec = 0;
+	s->fr.delivery.tv_usec = 0;
+	if ((res = fread(&ts, 1, sizeof(ts), s->f)) == sizeof(ts)) {
+		fs->lastts = ntohl(ts);
+		*whennext = fs->lastts * 4/45;
+	} else {
+		*whennext = 0;
+	}
+	return &s->fr;
+}
+
+static int vp8_write(struct ast_filestream *s, struct ast_frame *f)
+{
+	int res;
+	unsigned int ts;
+	unsigned short len;
+	int mark;
+
+	if (f->frametype != AST_FRAME_VIDEO) {
+		ast_log(LOG_WARNING, "Asked to write non-video frame!\n");
+		return -1;
+	}
+
+	mark = f->subclass.frame_ending ? FRAME_ENDED : 0;
+	ts = htonl(f->samples);
+	if ((res = fwrite(&ts, 1, sizeof(ts), s->f)) != sizeof(ts)) {
+		ast_log(LOG_WARNING, "Bad write (%d/4): %s\n", res, strerror(errno));
+		return -1;
+	}
+
+	len = htons(f->datalen | mark);
+	if ((res = fwrite(&len, 1, sizeof(len), s->f)) != sizeof(len)) {
+		ast_log(LOG_WARNING, "Bad write (%d/2): %s\n", res, strerror(errno));
+		return -1;
+	}
+
+	if ((res = fwrite(f->data.ptr, 1, f->datalen, s->f)) != f->datalen) {
+		ast_log(LOG_WARNING, "Bad write (%d/%d): %s\n", res, f->datalen, strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int vp8_seek(struct ast_filestream *fs, off_t sample_offset, int whence)
+{
+	/* No way Jose */
+	return -1;
+}
+
+static int vp8_trunc(struct ast_filestream *fs)
+{
+	int fd;
+	off_t cur;
+
+	if ((fd = fileno(fs->f)) < 0) {
+		ast_log(LOG_WARNING, "Unable to determine file descriptor for VP8 filestream %p: %s\n", fs, strerror(errno));
+		return -1;
+	}
+
+	if ((cur = ftello(fs->f)) < 0) {
+		ast_log(LOG_WARNING, "Unable to determine current position in VP8 filestream %p: %s\n", fs, strerror(errno));
+		return -1;
+	}
+
+	/* Truncate file to current length */
+	return ftruncate(fd, cur);
+}
+
+static off_t vp8_tell(struct ast_filestream *fs)
+{
+	off_t offset = ftell(fs->f);
+	return offset; /* XXX totally bogus, needs fixing */
+}
+
+static struct ast_format_def vp8_f = {
+	.name = "VP8",
+	.exts = "vp8",
+	.open = vp8_open,
+	.write = vp8_write,
+	.seek = vp8_seek,
+	.trunc = vp8_trunc,
+	.tell = vp8_tell,
+	.read = vp8_read,
+	.buf_size = BUF_SIZE + AST_FRIENDLY_OFFSET,
+	.desc_size = sizeof(struct vp8_desc),
+};
+
+static int load_module(void)
+{
+	vp8_f.format = ast_format_vp8;
+	if (ast_format_def_register(&vp8_f)) {
+		return AST_MODULE_LOAD_FAILURE;
+	}
+
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	return ast_format_def_unregister(vp8_f.name);
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Raw VP8 data",
+	.load = load_module,
+	.unload = unload_module,
+	.load_pri = AST_MODPRI_APP_DEPEND
+	);
