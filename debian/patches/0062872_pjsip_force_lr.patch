diff --git a/include/asterisk/res_pjsip.h b/include/asterisk/res_pjsip.h
index 3a9d61e..461a3be 100644
--- a/include/asterisk/res_pjsip.h
+++ b/include/asterisk/res_pjsip.h
@@ -1750,6 +1754,13 @@ struct ao2_container *ast_sip_get_endpoints(void);
  */
 struct ast_sip_endpoint *ast_sip_default_outbound_endpoint(void);
 
+/*
+ * \brief Retrieve force loose route setting value
+ *
+ * \retval Configured setting for loose route
+ */
+unsigned int ast_sip_force_lr(void);
+
 /*!
  * \brief Retrieve relevant SIP auth structures from sorcery
  *
diff --git a/res/res_pjsip.c b/res/res_pjsip.c
index cc86f90..c0ecd9b 100644
--- a/res/res_pjsip.c
+++ b/res/res_pjsip.c
@@ -1305,6 +1308,9 @@
                                         <synopsis>When set, Asterisk will dynamically create and destroy a NoOp priority 1 extension for a given
 					peer who registers or unregisters with us.</synopsis>
                                 </configOption>
+                <configOption name="force_lr" default="false">
+                    <synopsis>Append loose route (;lr) on requests to endpoints using outbound_proxy.</synopsis>
+                </configOption>
 				<configOption name="default_outbound_endpoint" default="default_outbound_endpoint">
 					<synopsis>Endpoint to use when sending an outbound request to a URI without a specified endpoint.</synopsis>
 				</configOption>
@@ -2680,6 +2689,11 @@ pjsip_dialog *ast_sip_create_dialog_uac(const struct ast_sip_endpoint *endpoint,
 		pj_list_init(&route_set);
 
 		pj_strdup2_with_null(dlg->pool, &tmp, outbound_proxy);
+
+        if (ast_sip_force_lr()) {
+            pj_strcat2(&tmp, ";lr");
+        }
+
 		if (!(route = pjsip_parse_hdr(dlg->pool, &ROUTE_HNAME, tmp.ptr, tmp.slen, NULL))) {
 			ast_log(LOG_ERROR, "Could not create dialog to endpoint '%s' as outbound proxy URI '%s' is not valid\n",
 				ast_sorcery_object_get_id(endpoint), outbound_proxy);
diff --git a/res/res_pjsip/config_global.c b/res/res_pjsip/config_global.c
index 8348a1e..58a40b1 100644
--- a/res/res_pjsip/config_global.c
+++ b/res/res_pjsip/config_global.c
@@ -38,6 +38,7 @@
 #define DEFAULT_REGCONTEXT ""
 #define DEFAULT_CONTACT_EXPIRATION_CHECK_INTERVAL 30
 #define DEFAULT_VOICEMAIL_EXTENSION ""
+#define DEFAULT_FORCE_LR "no"
 
 static char default_useragent[256];
 
@@ -64,6 +65,8 @@ struct global_config {
 	unsigned int max_initial_qualify_time;
 	/* The interval at which to check for expired contacts */
 	unsigned int contact_expiration_check_interval;
+    /* Append ;lr to outbound proxy requests */
+    unsigned int force_lr;
 };
 
 static void global_destructor(void *obj)
@@ -237,6 +240,18 @@ unsigned int ast_sip_get_max_initial_qualify_time(void)
 	return time;
 }
 
+unsigned int ast_sip_force_lr(void)
+{
+    struct global_config *cfg;
+
+    cfg = get_global_cfg();
+    if (!cfg) {
+        return 0;
+    }
+
+    return cfg->force_lr;
+}
+
 void ast_sip_get_default_from_user(char *from_user, size_t size)
 {
 	struct global_config *cfg;
@@ -373,6 +388,8 @@ int ast_sip_initialize_sorcery_global(void)
 	ast_sorcery_object_field_register(sorcery, "global", "contact_expiration_check_interval",
 		__stringify(DEFAULT_CONTACT_EXPIRATION_CHECK_INTERVAL),
 		OPT_UINT_T, 0, FLDSET(struct global_config, contact_expiration_check_interval));
+	ast_sorcery_object_field_register(sorcery, "global", "force_lr", DEFAULT_FORCE_LR,
+		OPT_BOOL_T, 1, FLDSET(struct global_config, force_lr));
 
 	if (ast_sorcery_instance_observer_add(sorcery, &observer_callbacks_global)) {
 		return -1;
